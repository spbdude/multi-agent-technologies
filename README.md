# Задача №1 Децентрализованное вычисление среднего 

## Кратко о проекте
Цель — смоделировать работу распределённой системы агентов, которые **без централизованного сбора данных** находят **среднее арифметическое** своих начальных значений.  
Реальный SPADE обычно использует XMPP-сервер; на Windows это нередко приводит к сложностям с настройкой и сетевыми портами, поэтому здесь используется **локальная имитация SPADE-подобного взаимодействия**: агенты обмениваются **только сообщениями** через очереди внутри процесса.

---

## Задача 1. Децентрализованное среднее арифметическое

### Требования
- Количество агентов формируется случайно (`random`).
- Связи между агентами формируются случайно (`random`).
- Граф связей должен быть **связным** (иначе часть агентов не сможет узнать информацию остальных).
- Синхронизация должна выполняться **только сообщениями** (никаких “общих переменных” для координации).
- В консоль выводится:
  - итоговое найденное среднее,
  - истинное среднее (для контроля корректности),
  - абсолютная ошибка,
  - стоимость вычислений по конфигурации.

### Генерация данных
Каждый агент получает начальное значение (случайное число, например в диапазоне 0..100).  
Для проверки корректности программа отдельно вычисляет «истинное» среднее обычной формулой — это не участвует в работе агентов, а используется только для сравнения результата.

### Сеть агентов (случайная и связная)
Сеть — неориентированный граф:
- узлы: агенты `agent0`, `agent1`, ...
- ребра: “соседство”, по которому разрешён обмен сообщениями

Построение выполняется так:
1. создаётся случайное остовное дерево (гарантия связности),
2. затем добавляются дополнительные ребра, чтобы степени узлов обычно были около 2–3 (насколько это возможно).

### Протокол обмена и вычисления (consensus)
Работа идёт итерациями. На каждой итерации:
1. **Рассылка**: каждый агент отправляет своё текущее значение всем соседям.
2. **Приём**: каждый агент получает значения от всех соседей.
3. **Обновление**: агент пересчитывает своё значение по формуле average-consensus.

Остановка:
- процесс прекращается, когда максимальное изменение значений между итерациями становится меньше `eps` (например, `1e-6`),
- либо по ограничению `max_iters`.

---

## Модель стоимости
Стоимость считается суммарно по всем агентам и итерациям. Тарифы:

- **Отправка сообщения агенту-соседу**: `0.1`
- **Отправка сообщения “в центр”** (например, финальный отчёт): `1000`
- **Арифметическая операция** (`+`, `-`, `*`, `/`, …): `0.01`
- **Ячейка памяти** (хранение одного числа): `0.1`

В конце программа печатает развернутый отчёт: все счётчики и итоговую стоимость.


# Задача №2 Децентрализованное вычисление среднего с помехами 

## Кратко о проекте
Цель — та же, что и в задаче 1: смоделировать распределённую систему агентов, которые без центра находят среднее арифметическое.  

---

### Требования
- Количество агентов и их связи формируются случайно (`random`).
- Граф связей должен быть **связным**.
- Синхронизация — **только сообщениями**.
- Наложить помехи:
  - потери сообщений: **10%**
  - временные отключения агентов на **1–2 итерации**
  - задержки доставки сообщений на **1–2 итерации**
- Использовать протокол **LVM (Local Voting Method)**.
- В консоль вывести:
  - итоговое найденное среднее,
  - истинное среднее (для контроля),
  - абсолютную ошибку,
  - стоимость вычислений по конфигурации,
  - (дополнительно) статистику помех: сколько сообщений потеряно/задержано, сколько шагов агенты были offline.

### Генерация данных
Каждый агент получает начальное значение (например, число 0..100).  
Отдельно считается «истинное» среднее обычной формулой — только для сравнения в конце.

### Сеть агентов (случайная и связная)
Сеть — неориентированный граф:
- узлы: `agent0`, `agent1`, ...
- ребра: каналы связи между соседями

Построение:
1. создаётся случайное остовное дерево (чтобы сеть была связной),
2. добавляются дополнительные ребра, чтобы степень узлов обычно была 2–3.

### Протокол LVM (локальное голосование)
Работа идёт итерациями. На каждой итерации агент:
1. **Рассылает** своё текущее значение соседям (если агент online).
2. **Получает** то, что реально дошло к этой итерации (с учётом потерь и задержек).
3. **Обновляет** значение по LVM:
   - каждое принятое значение соседа даёт “голос” разностью `(x_neighbor - x_self)`
   - агент делает шаг в сторону суммы голосов с коэффициентом `alpha`

Остановка:
- когда изменения становятся меньше `eps` и значения агентов почти совпадают,
- либо по ограничению `max_iters`.

### Помехи (эмуляция)
- **Потери 10%**: каждое сообщение может не дойти.
- **Задержка 1–2 итерации**: доставляется на `t+1` или `t+2`.
- **Offline 1–2 итерации**: агент временно не отправляет/не обрабатывает сообщения.

---

## Модель стоимости
Тарифы:
- отправка сообщения соседу: `0.1`
- отправка сообщения “в центр” (финальный отчёт): `1000`
- арифметическая операция: `0.01`
- ячейка памяти (одно число): `0.1`

В конце программа печатает итоговое среднее и отчёт по стоимости (счётчики и суммарную цену).
