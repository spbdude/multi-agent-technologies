# Задача №1 Децентрализованное вычисление среднего 

## Кратко о проекте
Цель — смоделировать работу распределённой системы агентов, которые **без централизованного сбора данных** находят **среднее арифметическое** своих начальных значений.  
Реальный SPADE обычно использует XMPP-сервер; на Windows это нередко приводит к сложностям с настройкой и сетевыми портами, поэтому здесь используется **локальная имитация SPADE-подобного взаимодействия**: агенты обмениваются **только сообщениями** через очереди внутри процесса.

---

## Задача 1. Децентрализованное среднее арифметическое

### Требования
- Количество агентов формируется случайно (`random`).
- Связи между агентами формируются случайно (`random`).
- Граф связей должен быть **связным** (иначе часть агентов не сможет узнать информацию остальных).
- Синхронизация должна выполняться **только сообщениями** (никаких “общих переменных” для координации).
- В консоль выводится:
  - итоговое найденное среднее,
  - истинное среднее (для контроля корректности),
  - абсолютная ошибка,
  - стоимость вычислений по конфигурации.

### Генерация данных
Каждый агент получает начальное значение (случайное число, например в диапазоне 0..100).  
Для проверки корректности программа отдельно вычисляет «истинное» среднее обычной формулой — это не участвует в работе агентов, а используется только для сравнения результата.

### Сеть агентов (случайная и связная)
Сеть — неориентированный граф:
- узлы: агенты `agent0`, `agent1`, ...
- ребра: “соседство”, по которому разрешён обмен сообщениями

Построение выполняется так:
1. создаётся случайное остовное дерево (гарантия связности),
2. затем добавляются дополнительные ребра, чтобы степени узлов обычно были около 2–3 (насколько это возможно).

### Протокол обмена и вычисления (consensus)
Работа идёт итерациями. На каждой итерации:
1. **Рассылка**: каждый агент отправляет своё текущее значение всем соседям.
2. **Приём**: каждый агент получает значения от всех соседей.
3. **Обновление**: агент пересчитывает своё значение по формуле average-consensus.

Остановка:
- процесс прекращается, когда максимальное изменение значений между итерациями становится меньше `eps` (например, `1e-6`),
- либо по ограничению `max_iters`.

---

## Модель стоимости
Стоимость считается суммарно по всем агентам и итерациям. Тарифы:

- **Отправка сообщения агенту-соседу**: `0.1`
- **Отправка сообщения “в центр”** (например, финальный отчёт): `1000`
- **Арифметическая операция** (`+`, `-`, `*`, `/`, …): `0.01`
- **Ячейка памяти** (хранение одного числа): `0.1`

В конце программа печатает развернутый отчёт: все счётчики и итоговую стоимость.




Задача 2 — Децентрализованное среднее с помехами (LVM, без XMPP)

## 1) Общая цель
Во второй задаче требуется расширить решение из задачи 1 и смоделировать более реалистичную распределённую среду, где обмен сообщениями и работа агентов происходят с ошибками и задержками.

Мы по-прежнему решаем задачу вычисления среднего арифметического начальных значений агентов децентрализованно, без сбора всех данных в одном месте, но теперь добавляем:
- потери сообщений (10%),
- временные отключения агентов (на 1–2 итерации),
- задержки доставки сообщений (на 1–2 итерации).

---

## 2) Начальные данные и проверка корректности
### Генерация значений
- Количество агентов выбирается случайно (random), например от 5 до 15.
- Каждый агент генерирует своё начальное число (например, целое от 0 до 100).

### Истинное среднее (только для проверки)
Программа отдельно вычисляет:
\[
\bar{x}_{true}=\frac{1}{n}\sum_{i=1}^n x_i(0)
\]
Это значение не используется агентами, а выводится в конце для оценки ошибки.

---

## 3) Сеть агентов (случайная и связная)
Агенты соединяются в случайный связный неориентированный граф:
- узлы — агенты agent0, agent1, ...
- ребра — возможность пересылки сообщений

Требование связности критично: если граф распадается на компоненты, общий результат для всех агентов невозможен.

Построение графа выполняется в два шага:
1. строится случайное остовное дерево (гарантированная связность),
2. добавляются дополнительные ребра, чтобы у узлов обычно было 2–3 соседа (насколько позволяет ограничение по степеням).

---

## 4) Эмуляция помех (условия задачи)
В задаче 2 используется модель “неидеальной” сети и доступности агентов.

### 4.1 Потери сообщений — 10%
Каждое отправляемое сообщение независимо теряется с вероятностью p_loss = 0.1.  
Потерянное сообщение не доставляется и не участвует в обновлении на стороне получателя.

### 4.2 Задержка доставки — 1–2 итерации
Если сообщение не потеряно, оно доставляется не мгновенно, а через задержку:
\[
delay \in \{1, 2\}
\]
То есть сообщение, отправленное на итерации t, реально попадает получателю на итерации t + delay.

Технически это реализовано через расписание доставки:  
deliver_iter -> список сообщений, которые нужно выдать агентам именно на этой итерации.

### 4.3 Временные отключения агентов — 1–2 итерации
На каждой итерации агент (если он online) может “уйти в offline” на 1–2 итерации.
Пока агент offline:
- он не отправляет сообщения,
- входящие сообщения считаются потерянными (не копятся).

Такое поведение имитирует реальные ситуации: сбой процесса агента, кратковременная недоступность, перегрузка.

---

## 5) Протокол LVM (Local Voting Method)
LVM — это итеративный протокол, где агент корректирует своё значение на основе “голосов” соседей.  
Каждый сосед голосует величиной разности между своим значением и значением агента.

Обозначения:
- \(x_i(t)\) — значение агента i на итерации t
- \(R_i(t)\) — множество соседей, от которых агент i реально получил сообщения к итерации t (с учётом потерь/задержек/offline)

### Шаг итерации
1) Отправка: агент i рассылает \(x_i(t)\) всем соседям (если online).  
2) Доставка: сеть доставляет часть сообщений (учитывая задержку и потери).  
3) Обновление (LVM):
\[
x_i(t+1) = x_i(t) + \alpha \sum_{j \in R_i(t)} \left(x_j(\text{полученное}) - x_i(t)\right)
\]

Где:
- \(\alpha\) — шаг алгоритма (малое число).  
В реализации выбран безопасный фиксированный шаг, например alpha = 0.2 при максимальной степени графа около 3.  
Меньший alpha обычно повышает устойчивость к задержкам/потерям, но может увеличить числоитераций.

### Интуиция
- Если значение соседа больше, чем у агента — вклад положительный и агент повышает своё значение.
- Если меньше — вклад отрицательный.
- Сумма голосов тянет значения к консенсусу даже при том, что часть сообщений иногда не приходит.

---

## 6) Критерий остановки
Из-за помех возможны небольшие колебания. Поэтому используются два критерия:
1) максимальное изменение за итерацию мало:
\[
\max_i |x_i(t+1) - x_i(t)| < \varepsilon
\]
2) разброс между агентами мал:
\[
\max_i x_i(t) - \min_i x_i(t) < \varepsilon
\]

Если оба выполняются — система считается сошедшейся.

---

## 7) Расчёт стоимости выполнения
Стоимость считается по тем же тарифам, что и в задаче 1:

- отправка сообщения соседу: 0.1
- отправка сообщения “в центр”: 1000
- арифметика (+, -, *, /): 0.01
- память (одно число): 0.1

Что учитывается:
- количество попыток отправить peer-to-peer сообщения (даже если сообщение потерялось, попытка была и стоит 0.1),
- число потерянных сообщений (как статистика качества сети),
- число сообщений с задержкой (статистика),
- число арифметических операций внутри LVM-обновлений,
- память: минимум по одному числу на агента (текущее x_i),
- “сообщение в центр” — один раз в конце (финальный отчёт/результат).

Дополнительно выводится:
- сколько “agent-steps” агенты были offline (количество итераций * количество агентов, находившихся offline на этих итерациях).

---

## 8) Вывод в консоль
В конце программа печатает:
- конфигурацию (seed, число агентов, параметры помех, alpha),
- начальные значения агентов,
- список соседей (граф),
- отчёт по стоимости,
- итог:
  - consensus estimate — оценка среднего по финальным значениям агентов,
  - true mean — истинное среднее начальных чисел,
  - abs error — абсолютная ошибка,
  - final spread — разброс между агентами (насколько хорошо достигнут консенсус).
